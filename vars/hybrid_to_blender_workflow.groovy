import groovy.transform.Field

@Field final String BRANCH_NAME_PREFIX = "hybrid_tag"


def isBuildSuccessful(String osName, Map options) {
    if (!options["finishedBuildStages"][osName]["successfully"]) {
        println("[ERROR] Build on ${osName} failed. Branch in RadeonProRenderUSD repo won't be created")

        return false
    }

    return true
}


def createUSDBranch(Map options) {
    try {
        if (!isBuildSuccessful("Windows", options) || !isBuildSuccessful("Ubuntu18", options)) {
            return
        }

        String autogeneratedBranch = "${BRANCH_NAME_PREFIX}_${env.TAG_NAME}"
        String targetRepoUrl = rpr_usdplugin_pipeline.PROJECT_REPO

        dir("RadeonProRenderUSD") {
            checkoutScm(branchName: "develop", repositoryUrl: targetRepoUrl, disableSubmodules: true)

            String message = "Triggered by Build #${env.BUILD_NUMBER}. Tag - ${env.TAG_NAME}"

            bat """
                git checkout -b ${autogeneratedBranch}
                git commit --allow-empty -m "${message}"
                git push origin ${autogeneratedBranch} --force
            """
        }
    } catch (e) {
        println("[ERROR] Failed to create branch in RadeonProRenderUSD repo")
        println(e)
    }
}


def createBlenderBranch(Map options) {
    try {
        if (!isBuildSuccessful("Windows", options) || !isBuildSuccessful("Ubuntu20", options)) {
            return
        }

        String autogeneratedBranch = env.BRANCH_NAME
        String targetRepoUrl = blender_usdhydra_plugin_pipeline.PROJECT_REPO

        dir("RadeonProRenderUSD") {
            checkoutScm(branchName: "master", repositoryUrl: targetRepoUrl, disableSubmodules: true)

            String message = options.commitMessage

            bat """
                git checkout -b ${autogeneratedBranch}
                git commit --allow-empty -m "${message}"
                git push origin ${autogeneratedBranch} --force
            """
        }
    } catch (e) {
        println("[ERROR] Failed to create branch in BlenderUSDHydraAddon repo")
        println(e)
    }
}


def clearOldBranches(String repositoryName, String repositoryUrl, Map options) {
    try {
        def hybridJobInfo

        withCredentials([string(credentialsId: 'jenkinsURL', variable: 'JENKINS_URL')]) {
            // get name and color (~status) of each branch/PR in Hybrid autojob
            hybridJobInfo = httpRequest(
                url: "${JENKINS_URL}/job/RadeonProRender-Hybrid/view/tags/api/json?tree=jobs[name,color]",
                authentication: "jenkinsCredentials",
                httpMode: "GET"
            )
        }

        def hybridJobInfoParsed = github_release_pipeline.parseResponse(hybridJobInfo.content)["jobs"]

        dir(repositoryName) {
            checkoutScm(branchName: "master", repositoryUrl: repositoryUrl, disableSubmodules: true)

            hybridJobInfoParsed.each { item ->
                if (item["color"] == "notbuilt") {
                    String branchName = "${BRANCH_NAME_PREFIX}_${item.name}"

                    Boolean branchExists = bat(script: "git ls-remote --heads ${repositoryUrl} ${branchName}",returnStdout: true)
                        .split('\r\n').length > 2

                    if (branchExists) {
                        // branch/PR doesn't exist. Remove remote branch
                        bat """
                            git push -d origin ${branchName}
                        """

                        println("[INFO] branch ${branchName} was removed")
                    }
                }
            }
        }
    } catch (e) {
        println("[ERROR] Failed to delete old branches")
        println(e)
    }
}


def replaceHybrid(String osName, Map options) {
    def parts = options.commitMessage.replace("Triggered by Build #", "").replace("Tag - ", "").split(". ")
    def hybridBuildNumber = parts[0] as Integer

    String tagName = env.BRANCH_NAME.split("_", 3)[2]

    String archiveName
    String libName

    switch(osName) {
        case "Windows":
            archiveName = "BaikalNext_Build-Windows.zip"
            libName = "HybridPro.dll"
            break

        default:
            archiveName = "BaikalNext_Build-Ubuntu18.tar.xz"
            libName = "HybridPro.so"
    }

    String artifactRemotePath = "/volume1/web/RadeonProRender-Hybrid/${tagName}/${hybridBuildNumber}/Artifacts/${archiveName}"

    downloadFiles(artifactRemotePath, ".")

    switch(osName) {
        case "Windows":
            unzip(zipFile: archiveName)
            utils.removeFile(this, osName, "RadeonProRender/binWin64/${libName}")
            utils.copyFile(this, osName, "BaikalNext/bin/${libName}", "RadeonProRender/binWin64/${libName}")
            break

        default:
            sh("tar -xf ${archiveName}")
            utils.removeFile(this, osName, "RadeonProRender/binUbuntu18/${libName}")
            utils.copyFile(this, osName, "BaikalNext/bin/${libName}", "RadeonProRender/binUbuntu18/${libName}")
    }

    utils.removeFile(this, osName, archiveName)
    utils.removeDir(this, osName, "BaikalNext")
}
